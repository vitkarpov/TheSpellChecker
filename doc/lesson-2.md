## Глава 2

### Введение

Первый документ, который вы создали при планировании — список компонент проекта с оценкой их сложности. И первым в списке шел словарь, поэтому не трудно понять, чем нужно заняться в первую очередь.

Сперва стоит сделать самую сложную часть проекта. Для этого есть несколько причин:

* если не получится сделать самое сложное — нет смысла приступать и к простому;
* как только сложная часть закончена уже легче более точно оценить сколько нужно времени, чтобы все доделать;
* если самое сложное еще впереди, то все время ощущается психологическое напряжение.

Итак, определимся с тем, что должен уметь словарь:

* клиентский код должен иметь возможность задать вопрос «Это слово правильное?» и словарь должен на него ответить;
* ответ нужно искать быстро;
* должна быть возможность загружать специальные словари (словарь, здесь, это просто список слов, а не структура данных)

Эти требования ставят некоторые вопросы, которые мы не учли вначале: что считать «словом», как получать слова из черновиков публикаций, откуда брать слова для словарей.

Самое время обновить схему, составленную ранее:

![](https://yadi.sk/d/pkZLcjgcTB9NT_XXL.jpg)

и список компонент:

* **Словарь**
* **Проверка**
* **Слово**
* **Отчет**
* **Список слов**
* **Командная строка**

Разработка софта не обходится без возникновения новых задач в уже по ходу разработки, так что не стоит переживать из-за того, что список растет. Однако стоит отдавать себе отчет, что время разработки неизбежно увеличится: нужно понимать это (и сделать так, чтобы другие участники проекта поняли).

Чтобы не зацикливаться на деталях, иногда требуется принять решение, пусть и не совсем точное. Будем считать, что слова — последовательность символов без пробелов, и что словарь содержит слова по одному в каждой строке. В будущем можно пересмотреть это решение.

### Класс Dictionary

Более или менее мы формализовали понятие словаря. Словарь нужен для поиска в нем слов. Как это реализовать на `C++`?

Язык программирования `C++` мультипарадигменный язык. Это значит, что одно и то же можно сделать нескольми способами. В мире программ на `C` вы могли бы сделать словь набором функций. Можно создать шаблон, следуя принципам функционального программирования. Можно создать класс.

Кажется, что последний способ (создать класс) в данной ситуации самый подходящий. Классы используется когда нужно скрыть детали реализации за простым интерфейсом или когда нужно создать несколько объектов с похожими свойствами (например, обычный и технический словарь, в нашем случае).

Однако, использование классов не всегда верное решение. Не стоит проектировать программу «классами», в конце концов, это всего лишь инструмент.

Интерфейс класса может выглядеть как-то так:

```с++
#include <string>

class Dictionary {
    public:
        Dictionary( const std::string & fname );
        bool Check( const std::string & word  ) const;
};
```

Здесь стоит обратить внимание на несколько вещей.

Во-первых, не используется [конструктор по умолчанию](http://ru.wikipedia.org/wiki/%CA%EE%ED%F1%F2%F0%F3%EA%F2%EE%F0_%EF%EE_%F3%EC%EE%EB%F7%E0%ED%E8%FE), вместо этого объект инициализируется по имени файла (файла со словарем).
Обычно имеет смысл определять констуктор явно и не использовать констуктор по умолчанию, потому что иначе новый объект не будет уметь ничего делать — в данном случае, искать слова в словаре.

Во-вторых, используется тип `string` из стандартной библиотеки, вместо `char`, как можно было ожидать. Это обычно бывает удобнее, однако не всегда, будут рассмотрены случаи, когда использование `string` не удобно.

В-третьих, аргументы функции передают по ссылке, чтобы избежать копирования и нерационального расхода памяти.

И наконец, используется `const`, чтобы указать, что аргументы неизменны и, что функция `Check` может быть вызвана для константного экземпляра класса `Dictionary`.

Если что-то из этого показалось незнакомым вовсе, стоит обратиться к справочнику или любому введению в язык `C++`.

Код приведенный выше нужно поместить в файл `dictionary.h` и сохранить его в директорию `inc`. Определение класса должно быть в этом файле, чтобы можно было включать его в тех местах (других файлах), где он будет нужен.

Например, теперь можно включить заголовочный файл в `main.cpp`:

```c++
#include <iostream>
#include <string>
#include "dictionary.h"

using namespace std;

int main() {
    cout << "||T |||h |||e |||       |||S |||p |||e |||l |||l ||\n";
    cout << "||__|||__|||__|||_______|||__|||__|||__|||__|||__||\n";
    cout << "|/__\\|/__\\|/__\\|/_______\\|/__\\|/__\\|/__\\|/__\\|/__\\|\n";
    cout << "____ ____ ____ ____ ____ ____ ____ \n";
    cout << "||C |||h |||e |||c |||k |||e |||r ||\n";
    cout << "||__|||__|||__|||__|||__|||__|||__||\n";
    cout << "|/__\\|/__\\|/__\\|/__\\|/__\\|/__\\|/__\\|\n";

    Dictionary d( "mydict.dat" );

    string word = "dog";

    if ( d.Check( word ) ) {
        cout << word << " is OK\n";
    }
    else {
        cout << word << " is misspelt \n";
    }
}
```

Если сохранить файл и попровать скомпилировать программу, то вы увидете, наверное, одно из самых распространенных сообщений компилятора об ошибке.

Об этом далее.

### Ошибки компиляции и линковки.

Итак, попробуем скомпилировать то, что получилось.

```
$ g++ src/main.cpp -o bin/spc
```

Черт! Немедленно вываливается сообщение об ошибке:

```
fatal error: dictionary.h: No such file or directory
compilation terminated.
```

Компилятор говорит нам о том, что он не смог найти указанный файл `dictionary.h`. Обратите внимание, что другие заголовочные файлы (`<iostream>`, `<string>`) были найдены. Очевидно, что необходимо рассказать компилятору где искать проектные заголовочные файлы.

Есть специльный флаг `g++`, который позволяет указать это.

```
$ g++ -I inc src/main.cpp -o bin/spc
```

Ошибка про пропавший файл должна исчезнуть. Однако, появляются другие, еще более непонятные ошибки:

```
main.cpp:(.text+0xb2): undefined reference to `Dictionary::Dictionary(std::string const&)'
main.cpp:(.text+0x12a): undefined reference to `Dictionary::Check(std::string const&)'
collect2: ld returned 1 exit status
```

На самом деле это ошибки не компилятора. Код правильный, однако, линковщик (`ld` — программа, которая вернула код 1, код выхода с ошибкой, это и есть линковщик) жалуется на то, что конструктор `Dictionary` и функция `Check` не определены.

Как можно понять из сообщения об ошибке «undefined reference» линковщик не может найти весь код, необходимый для создания исполняемого файла. Причин такой ошибки может быть несколько, однако синтаксическая ошибка — не одна из них.

На самом деле, причина в том, что мы только задекларировали интерфейс класса `Dictionary`. Нужно сделать реализацию.

Это можно сделать как в том же файле `dictionary.h`, если класс не очень большой, но вообще говоря делать это нужно в отдельном файле, чтобы отделить мух от котлет.

```
#include <string>
class Dictionary {
    public:
        Dictionary( const std::string & fname ) {
        }
        bool Check( const std::string & word ) const {
            return false;
        }
};
```

Сейчас программа должна компилироваться:

```
$ g++ -I inc src/main.cpp -o bin/spc
$ bin/spc
||T |||h |||e |||       |||S |||p |||e |||l |||l ||
||__|||__|||__|||_______|||__|||__|||__|||__|||__||
|/__\|/__\|/__\|/_______\|/__\|/__\|/__\|/__\|/__\|
____ ____ ____ ____ ____ ____ ____ 
||C |||h |||e |||c |||k |||e |||r ||
||__|||__|||__|||__|||__|||__|||__||
|/__\|/__\|/__\|/__\|/__\|/__\|/__\|

dog is misspeled
```

Очевидно, что слово «dog» написано правильно, но несмотря на то, что программа пока не делает реальной проверки, она запускается!

Перед тем как приступить к настоящей реализации словаря, разберем еще одну возможную ошибку.

Попробуйте задекларировать заголовочный файл дважды:

```
#include <iostream>
#include <string>
#include "dictionary.h"
#include "dictionary.h"
using namespace std;
```

Перекомпилируйте и вы увидете сообщение:

```
error: redefinition of 'class Dictionary'
```