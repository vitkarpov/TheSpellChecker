## Глава 3

### Введение

В прошлой главе мы создавали объект словаря посредством чтения данных из файла. Файловый ввод и вывод один из самых важных аспектов программирования на C++, так что я потрачу некоторое время на введение в эту тему. Далее разберемся с обработкой ошибок, заполним словарь реальными данными и посмотрим достаточно ли быстро работает то, что мы написали.

### Потоки

Основной инструмент для организации ввода и вывода данных — потоки. Все начинающие программисты знакомы с потоками стандартного ввода и вывода: `cin` и `cout`, однако не все понимают как ими пользоваться.

Рассмотрим такой код:

```cpp
int n;
cin >> n;
```

Есть много причин почему не стоит так делать, самое главное — вы не можете контролировать тип данных, который реально окажется в `n`, как следствие программа может аварийно завершиться.

Программа должна читать текстовые данные не ожидая определенный тип (за исключением бинарных данных), а затем парсить их.

Код выше следует переписать, например, так:

```cpp
string line;
while( getline( cin, line ) )  {
    parse( line );
}
```

Здесь `parse` — функция, которую мы должны написать сами. Она принимает строку, разбивает на слова и проверяет типа данных каждого. Далее в проекте нам еще нужно будет сделать парсер. Хорошо, что построчная разбивка уже есть — getline стандартной библиотеки.

Код выше — каконический способ чтения стандартного ввода в `C++`. Канонический означает, что лучше делать так, если нет серьезной причины делать иначе.

К сожалению, большинство начинающих программистов пишут такой код:

```cpp
string line;
while( !cin.eof() ) {
    getline( cin, line );
    // do stuff with line
}
```

Выглядит разумно, но на самом деле это не так.

Функция `eof` проверяет возвращает специальный флаг окончания потока уже после того как операция ввода завершится — в таком случае никак не проверить результат следующей операции.

Наглядный пример когда `oef` работает не так как ожидается:

```
string line;
int n = 1;
while( !cin.eof() ) {
    getline( cin, line );
    cout << n++ << " " << line << endl;
}
```

Представим, что файл будет пустой. Тогда условие цикла `!cin.eof()` проходит, потому что чтения из стандартного ввода еще не было, и мы попадает в тело цикла. Далее функция `getline` возвращает ошибку, которая никак не обрабатывается, поэтому мы прибавляем 1 к номеру строки.

Код выше стоит переписать так:

```
string line;
int n = 1;
while( getline( cin, line ) ) {
    cout << n++ << " " << line << "\n";
}
```

Отсюда вывод: не используйте `eof` в условиях для входа в цикл (можно в теле цикла, чтобы прервать выполнение) и проверяйте результат обработки каждой операции ввода.
Обычно стоит проверять результат обработки файла и сообщать об ошибках, хотя вывод обычно меньше подвержен ошибка, чем ввод.

Возникает вопрос, как же на самом деле работает такой код:

```
while( getline( cin, line ) ) {
    ...
}
```

Если посмотреть на реализацию `getline` в стандартной библиотеке, там будет примено следующее:

```
istream & getline( istream & is, const string & s ) {
    // read input into 's' from 'is' somehow
    return is;
}
```

Другими словами, `getline` возвращает объект потока, который является первым аргументом так, что проверка выполняется *после* операции чтения и не внутри функции `getline`. Как это происходит?

Компилятор знает, что оператор `while` должен принимать один из встроенных типов (`integer`, `pointer`, ...) и будет вызван оператор приведение к указателю типа void, который для класса istream перегружен и выглядит как-то так:

```
class istream {
    ...
    operator void *() {
        if ( eof() || other-failure-conditions ) {
            return 0;
        }
        else {
            return this;
        }
    }
};
```

Так что, когда выполнение `getline` приводит к тому, что достигается конец потока, в оператор `while` вернется в конечном итоге `0` — в результате приведения типа.

### Файловый поток

По аналогии с `cin` и `cout` можно создать файловой поток — для чтения и записи в файл, а не стандартный ввод и вывод. Для этого существуют типы `ifstream` и `ofstream`.  Есть так же третий тип потока `fstream`, который может быть использован как для чтения так и для записи.

Конструктор объекта файлового потока принимает один аргумент — имя файла:

```
ofstream out( "results.txt" );
```

Всегда стоит проверять действительно ли поток был создан, эта операция довольно часто завершается ошибкой:

```
ofstream out( "results.txt" );
if ( !ofstream.is_open() ) {
    // report error somehow
}
```

Тип параметра должен быть `char *`, и это обычно приводит к раздражающим ошибкам компилятора.

Например,

```
string name = "results.txt";
ofstream out( name );
```

вызовет следующую ошибку при компиляции:

```
error: no matching function for call to

  'basic_ofstream<char>::basic_ofstream(string&)'
```

Можно долго смотреть на это сообщение об ошибке, прежде чем сообразить, что `ofstream` на самом деле это [typedef-объявление](http://en.wikipedia.org/wiki/Typedef) для `basic_ofstream<char>`, что тип параметра в конструкторе должен быть `char *` и что для `string` нет автоматического приведения к `char *`.

Надо выполнить приведение вручную:

```
string fname = "results.txt";
ofstream out( fname.c_str() );
```

### Вернемся к нашей программе
