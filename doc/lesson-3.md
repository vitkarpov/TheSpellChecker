## Глава 3

### Введение

В прошлой главе мы создавали объект словаря посредством чтения данных из файла. Файловый ввод и вывод один из самых важных аспектов программирования на C++, так что я потрачу некоторое время на введение в эту тему. Далее разберемся с обработкой ошибок, заполним словарь реальными данными и посмотрим достаточно ли быстро работает то, что мы написали.

### Потоки

Основной инструмент для организации ввода и вывода данных — потоки. Все начинающие программисты знакомы с потоками стандартного ввода и вывода: `cin` и `cout`, однако не все понимают как ими пользоваться.

Рассмотрим такой код:

```cpp
int n;
cin >> n;
```

Есть много причин почему не стоит так делать, самое главное — вы не можете контролировать тип данных, который реально окажется в `n`, как следствие программа может аварийно завершиться.

Программа должна читать текстовые данные не ожидая определенный тип (за исключением бинарных данных), а затем парсить их.

Код выше следует переписать, например, так:

```cpp
string line;
while( getline( cin, line ) )  {
    parse( line );
}
```

Здесь `parse` — функция, которую мы должны написать сами. Она принимает строку, разбивает на слова и проверяет типа данных каждого. Далее в проекте нам еще нужно будет сделать парсер. Хорошо, что построчная разбивка уже есть — getline стандартной библиотеки.

Код выше — каконический способ чтения стандартного ввода в `C++`. Канонический означает, что лучше делать так, если нет серьезной причины делать иначе.

К сожалению, большинство начинающих программистов пишут такой код:

```cpp
string line;
while( !cin.eof() ) {
    getline( cin, line );
    // do stuff with line
}
```

Выглядит разумно, но на самом деле это не так.

Функция `eof` проверяет возвращает специальный флаг окончания потока уже после того как операция ввода завершится — в таком случае никак не проверить результат следующей операции.

Наглядный пример когда `oef` работает не так как ожидается:

```
string line;
int n = 1;
while( !cin.eof() ) {
    getline( cin, line );
    cout << n++ << " " << line << endl;
}
```

Представим, что файл будет пустой. Тогда условие цикла `!cin.eof()` проходит, потому что чтения из стандартного ввода еще не было, и мы попадает в тело цикла. Далее функция `getline` возвращает ошибку, которая никак не обрабатывается, поэтому мы прибавляем 1 к номеру строки.

Код выше стоит переписать так:

```
string line;
int n = 1;
while( getline( cin, line ) ) {
    cout << n++ << " " << line << "\n";
}
```

Отсюда вывод: не используйте `eof` в условиях для входа в цикл (можно в теле цикла, чтобы прервать выполнение) и проверяйте результат обработки каждой операции ввода.
Обычно стоит проверять результат обработки файла и сообщать об ошибках, хотя вывод обычно меньше подвержен ошибка, чем ввод.

Возникает вопрос, как же на самом деле работает такой код:

```
while( getline( cin, line ) ) {
    ...
}
```

Если посмотреть на реализацию `getline` в стандартной библиотеке, там будет примено следующее:

```
istream & getline( istream & is, const string & s ) {
    // read input into 's' from 'is' somehow
    return is;
}
```

Другими словами, `getline` возвращает объект потока, который является первым аргументом так, что проверка выполняется *после* операции чтения и не внутри функции `getline`. Как это происходит?

Компилятор знает, что оператор `while` должен принимать один из встроенных типов (`integer`, `pointer`, ...) и будет вызван оператор приведение к указателю типа void, который для класса istream перегружен и выглядит как-то так:

```
class istream {
    ...
    operator void *() {
        if ( eof() || other-failure-conditions ) {
            return 0;
        }
        else {
            return this;
        }
    }
};
```

Так что, когда выполнение `getline` приводит к тому, что достигается конец потока, в оператор `while` вернется в конечном итоге `0` — в результате приведения типа.


### Файловый поток

По аналогии с `cin` и `cout` можно создать файловой поток — для чтения и записи в файл, а не стандартный ввод и вывод. Для этого существуют типы `ifstream` и `ofstream`.  Есть так же третий тип потока `fstream`, который может быть использован как для чтения так и для записи.

Конструктор объекта файлового потока принимает один аргумент — имя файла:

```
ofstream out( "results.txt" );
```

Всегда стоит проверять действительно ли поток был создан, эта операция довольно часто завершается ошибкой:

```
ofstream out( "results.txt" );
if ( !ofstream.is_open() ) {
    // report error somehow
}
```

Тип параметра должен быть `char *`, и это обычно приводит к раздражающим ошибкам компилятора.

Например,

```
string name = "results.txt";
ofstream out( name );
```

вызовет следующую ошибку при компиляции:

```
error: no matching function for call to

  'basic_ofstream<char>::basic_ofstream(string&)'
```

Можно долго смотреть на это сообщение об ошибке, прежде чем сообразить, что `ofstream` на самом деле это [typedef-объявление](http://en.wikipedia.org/wiki/Typedef) для `basic_ofstream<char>`, что тип параметра в конструкторе должен быть `char *` и что для `string` нет автоматического приведения к `char *`.

Надо выполнить приведение вручную:

```
string fname = "results.txt";
ofstream out( fname.c_str() );
```

### Вернемся к нашей программе

Обобщив все то, что было сказано выше можно написать код конструктора словаря:

```c++
Dictionary( const std::string & fname ) {
    std::ifstream wlist( fname.c_str() );
    std::string word;
    while( std::getline( wlist, word ) ) {
        mWords.insert( word );
    }
}
```

Теперь нужно протестировать, что файл открывается корректно и выход из цикла происходит по достижение `eof`, а не по другой причине.

```c++
Dictionary( const std::string & fname ) {
    std::ifstream wlist( fname.c_str() );
    if ( ! wlist.is_open() ) {
        // сообщение об ошибке открытия файла
    }
    std::string word;
    while( std::getline( wlist, word ) ) {
        mWords.insert( word );
    }
    if ( ! wlist.eof() ) {
        // сообщение об ошибке чтения файла
    }
}
```

А как именно нужно сообщить об ошибке? Есть несколько вариантов:

* вернуть код ошибки;
* установить какой-нибудь флаг в объекте, которые потом можно проверить;
* установить глобальную переменную, номер ошибки, как в C;
* кинуть исключение;

Только последний способ может претендовать на общий метод (например, из констуктора нельзя вернуть код ошибки) и в C++ это общепринятый метод обработки ошибок. Некоторые люди могут спорить с этим, приводя различные аргументы, начиная от производительности и заканчивая сложностью архитектуры.

Мой опыт говорит о том, что исключения — наилучший способ сохранить код чистым и являются незначительными в снижении производительности. Обратите внимание, что речь идет про обработку ошибок — не стоит постоянно возвращать исключения или использовать их как механизм контроля потока выполнения программы.

### Выбрасывание исключений

Итак, если теперь стоит обсудить какие именно бывают исключения. В C++ выбор достаточно большой — в качестве иключения можно бросить любой объект. Например, в нашем случае самый простой и грязный способ — выбросить указатель на начало массива символов:

```c++
if ( ! wlist.is_open() ) { 
    throw "could not open file";
} 
```

Это сработает, но здесь есть несколько проблем. Во-первых, создавать сообщение об ошибке таким образом небезопасно, а, во-вторвых, не получится понять где ваши ошибки, а где пользователей.

Хорошей практикой является создать свои классы, наследуя их от класса `runtime_error` стандартной библиотеки C++.

Чтобы создать свой собственный тип исключения добавьте новый заголовочный файл `error.h` в папку `inc`:

```c++
#ifndef INC_ERROR_H
#define INC_ERROR_H
#include <stdexcept>
#include <string>
class ScheckError : public std::runtime_error {
   public:
      ScheckError( const std::string & emsg )  : std::runtime_error( emsg ) {}
};
#endif
```

Здесь важно отметить:

* т.к. это заголовочный файл, то необходимо предовратить ошибку повторного включения, с помощью `#ifndef`;
* класс `runtime_error` определен в `<stdexcept>`, а не `<exception>` (постоянно забываю);
* вы должны передать сообщение об ошибке из дочернего `ScheckError` в родительский `std::runtime_error` по списку инициализации.

Далее можно модифицировать конструктор словаря, включив предварительно `error.h`

```c++
Dictionary( const std::string & fname ) {
    std::ifstream wlist( fname.c_str() );
    if ( ! wlist.is_open() ) {
        throw ScheckError( "Could not open dictionary file " + fname );
    }
    std::string word;
    while( std::getline( wlist, word ) ) {
        mWords.insert( word );
    }
    if ( ! wlist.eof() ) {
        throw ScheckError( "Error reading dictionary file " + fname );
    }
}
```

Перед тем как добавить обработку исключения, стоит проверить, что будет если этого не сделать.

Измените `main.cpp` так, чтобы использовался несуществующий путь к файлу в конструкторе словаря:

```c++
Dictionary d( "data/not-there.dat" );
```

и перекомпилируйте проект:

```
g++ -I inc src/main.cpp -o bin/scheck
```

Теперь если запустить программу, создание словаря выбросит исключение, потому что такой файл открыть неудалось. В стандарте C++ сказано, что если обработки исключения нет, то будет вызвана стандартная функция `terminate()`, однако какие именно сообщения функция должна сообщать не определено.

В моей реализации gcc на Windows, получается следующее:

```
terminate called after throwing an instance of 'ScheckError'
```

и далее программа завершается аварийно с несколькими сообщениями от операционной системы.

Очевидно, хочется нечто более контролируемое — нужно написать обработку исключения.

### Обработка исключений

Основной правило обработки исключений — делать это на как можно большем уровне абстракции программы, ведь обычно выбрасываются исключения где-то в глубине логики программы, в низкоуровневых функций. Делать это нужно потому, что на более высоком уровне абстракции понятно что делать с исключением: что именно сообщить, если это не критическая ошибка, как восстановить работу программы.

Обычно не стоит обрабатывать исключения в том месте, где была вызвана функция внутри которой было выброшено исключение — лучше вернуть исключение из этой функции используя `return`.

Обработку исключений лучше сделать в функции `main`, куда будут всплывать все исключения с разных частей приложения.

В нашем случае, `main` это единственное разумное место, куда нужно положить обработку исключений. 